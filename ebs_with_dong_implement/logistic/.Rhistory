library(foreach)
library(mcmcse)
setwd("C:/Users/Hp/Documents/mcmc_with_rahul/logistic_detailed_checks/linear")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
grad_lin <- function(sg,y,x){
(x %*% (sg) - y) %*% x
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 1
nparm = 20
A = diag(nparm)
cns = seq(0.01, 1, by = 0.05)
ncores_par = 1
eta_cns = 1
eta_typ = 1
sam_siz = c(2e6,5e6,1e7)#1e5,2e5,5e5,8e5,
qlev = 0.95
alp = .51
burn_in = 1000
nam_matrix = "indep"
sam_siz <- 2e6
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
sigm <- qr.solve(A)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cn <- 1
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
#noisy Observed Data
y <- x %*% parm + rnorm((n + burn_in), mean = 0, sd = 1)
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * grad_lin(  sg[i - 1,], y[i], x[i,])
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
for ( smpl in 1 : length(sam_siz))
{
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm), "Oracle"))
#IBS  related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.05)
forb_ibs[cn, smpl]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn, smpl] <- norm(ibs_mean, "F")
volm_ibs[cn, smpl]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm), "IBS"))
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 1){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS"))
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS Lugsail"))
count = count + 1
}
}
}
rm(list = ls())
set.seed(3)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
setwd("C:/Users/Hp/Documents/mcmc_with_rahul/logistic_detailed_checks/linear")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
grad_lin <- function(sg,y,x){
(x %*% (sg) - y) %*% x
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 1
nparm = 20
A = diag(nparm)
cns = seq(0.01, 1, by = 0.05)
ncores_par = 1
eta_cns = 1
eta_typ = 1
sam_siz = c(2e6,5e6,1e7)#1e5,2e5,5e5,8e5,
qlev = 0.95
alp = .51
burn_in = 1000
nam_matrix = "indep"
sam_siz <- 1e5
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
sigm <- qr.solve(A)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cn <- 1
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
#noisy Observed Data
y <- x %*% parm + rnorm((n + burn_in), mean = 0, sd = 1)
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * grad_lin(  sg[i - 1,], y[i], x[i,])
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
for ( smpl in 1 : length(sam_siz))
{
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm), "Oracle"))
#IBS  related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.05)
forb_ibs[cn, smpl]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn, smpl] <- norm(ibs_mean, "F")
volm_ibs[cn, smpl]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm), "IBS"))
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 1){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS"))
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS Lugsail"))
count = count + 1
}
}
}
rm(list = ls())
set.seed(3)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
setwd("C:/Users/Hp/Documents/mcmc_with_rahul/logistic_detailed_checks/linear")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
grad_lin <- function(sg,y,x){
(x %*% (sg) - y) %*% x
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 1
nparm = 20
A = diag(nparm)
cns = seq(0.1, 1.5, by = 0.2)
ncores_par = 1
eta_cns = 1
eta_typ = 1
sam_siz = c(2e6,5e6,1e7)#1e5,2e5,5e5,8e5,
qlev = 0.95
alp = .51
burn_in = 1000
nam_matrix = "indep"
sam_siz <- 1e5
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
sigm <- qr.solve(A)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cn <- 1
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
#noisy Observed Data
y <- x %*% parm + rnorm((n + burn_in), mean = 0, sd = 1)
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * grad_lin(  sg[i - 1,], y[i], x[i,])
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
for ( smpl in 1 : length(sam_siz))
{
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm), "Oracle"))
#IBS  related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.05)
forb_ibs[cn, smpl]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn, smpl] <- norm(ibs_mean, "F")
volm_ibs[cn, smpl]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm), "IBS"))
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 1){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS"))
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS Lugsail"))
count = count + 1
}
}
}
(cns^2)*(n^(alp))
rm(list = ls())
set.seed(3)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
setwd("C:/Users/Hp/Documents/mcmc_with_rahul/logistic_detailed_checks/logistic")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
gradnt_log <- function(y,a,sg){
tmp <- (c( 1 + exp(  y*t(a )%*% (sg))))
p_thet <- 1/ tmp
return(-y*p_thet*a)
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 1
nparm = 20
A = diag(nparm)
cns = seq(0.1, 1.5, by = 0.2)
ncores_par = 1
eta_cns = 1
eta_typ = 1
sam_siz = c(2e6,5e6,1e7)#1e5,2e5,5e5,8e5,
qlev = 0.95
alp = .51
burn_in = 1000
nam_matrix = "indep"
sam_siz <- 1e5
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
load("out/sigm_inv_logist.RData")
sigm_inv <- get(paste("sigm_inv_",nam_matrix,"_nparm_", nparm, sep= ""))
sigm <- qr.solve(sigm_inv)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cn <- 1
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
p1 <- 1/(1 + exp(-x %*% parm))# Prob of success for 1 (1-p1 is for -1)
y<-2*rbinom(n + burn_in, size = 1, prob = p1) - 1
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * gradnt_log( y[i], x[i,], sg[i - 1,])
if(sum(is.na(gradnt_log( y[i], x[i,], sg[i - 1,]))) >= 1){print(c(sg[i-1],i))}
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
for ( smpl in 1 : length(sam_siz))
{
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm), "Oracle"))
#IBS  related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.1)
forb_ibs[cn, smpl]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn, smpl] <- norm(ibs_mean, "F")
volm_ibs[cn, smpl]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
print(paste(sam_siz[smpl]  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm), "IBS"))
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 1){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS"))
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[smpl,  cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[smpl,  cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[smpl,  cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[smpl,  cn, count] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
print(paste("const", cns[mk], "beta type", bt_typ, sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm), "EBS Lugsail"))
count = count + 1
}
}
}
nparm <- 20
an <- 28
crt_val_ebs <- qf(qlev, df1 = nparm, df2 = (an - nparm))
sam_siz <- c( 1e5, 2e5, 5e5, 8e5, 1e6, 5e6,1e7)
updt_crt <- vector()
for ( smpl in 1: length(sam_siz)){
bn <- floor(sam_siz[smpl]/an)
print(bn)
updt_crt[smpl] <- ( sam_siz[smpl] * nparm / ((an - nparm) * bn))
}
crt_val_ebs <- crt_val_ebs * updt_crt
print(crt_val_ebs)
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/ebs_with_dong_implement/logistic")
load("C:/Users/Hp/Desktop/logistic_proj_new_indep_n_1e+06_dim_20.RData")
cover_orc
cover_ibs
cover_ebs
cover_ebs_ls
qlev = 0.95
qnorm((1+qlev)/2)
gradnt_log <- function(y,a,sg){
tmp <- (c( 1 + exp(  y*t(a )%*% (sg))))
p_thet <- 1/ tmp
return(-y*p_thet*a)
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
log_batch_fn <- function(max_sam = 1e5, Rep = 1, nparm = 5, A = diag(nparm), cns = c(0.1, 1), ncores_par = 1, eta_cns = 0.5, eta_typ = 1,  sam_siz = c(1e5,2e5,5e5,8e5,1e6,5e6,1e7), qlev = 0.95, alp = .505, burn_in = 1000, nam_matrix = "indep"){
sam_siz <- sam_siz[sam_siz <= max_sam]
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
load("out/sigm_inv_logist.RData")
sigm_inv <- get(paste("sigm_inv_",nam_matrix,"_nparm_", nparm, sep= ""))
sigm <- qr.solve(sigm_inv)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
}
gradnt_log <- function(y,a,sg){
tmp <- (c( 1 + exp(  y*t(a )%*% (sg))))
p_thet <- 1/ tmp
return(-y*p_thet*a)
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
max_sam = 1e5
Rep = 1
nparm <- 20
nam_matrix = "indep"
A = diag(nparm)
cns = seq(0.2, 0.6, by =0.1)
eta_cns = 0.5
sam_siz = c(1e5,2e5,5e5,8e5,1e6,5e6,1e7)
qlev = 0.95
alp = .505
burn_in = 1000
nam_matrix = "indep"
sam_siz <- sam_siz[sam_siz <= max_sam]
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
load("out/sigm_inv_logist.RData")
sigm_inv <- get(paste("sigm_inv_",nam_matrix,"_nparm_", nparm, sep= ""))
sigm <- qr.solve(sigm_inv)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cn <- 1
crt_val <- qnorm((1+qlev)/2)
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
p1 <- 1/(1 + exp(-x %*% parm))# Prob of success for 1 (1-p1 is for -1)
y<-2*rbinom(n + burn_in, size = 1, prob = p1) - 1
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * gradnt_log( y[i], x[i,], sg[i - 1,])
if(sum(is.na(gradnt_log( y[i], x[i,], sg[i - 1,]))) >= 1){print(c(sg[i-1],i))}
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
smpl <- 1
sam_siz[smpl]
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
print(asg)
parm
ons <- rep(1,nparm)
tmp_sd <- sqrt((t(ons) %*% solve(sigm) %*% ons)/sam_siz[smpl])
low_orc <- t(ons) %*% asg - crt_val * tmp_sd
up_orc <-  t(ons) %*% asg + crt_val * tmp_sd
cover_orc[cn, smpl] <- as.numeric (t(ons) %*% parm <= up_orc&t(ons) %*% parm >= low_orc)
t(ons) %*% parm
up_orc
low_orc
parm
up_orc&t(ons) %*% parm
t(ons) %*% parm
t(ons) %*% parm
t(ons) %*% parm <= up_orc & t(ons) %*% parm >= low_orc
t(ons) %*% parm
up_orc
crt_val
tmp_sd
t(ons) %*% asg
t(ons) %*% asg
up_orc
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.1)
tmp_sd <- sqrt((t(ons) %*% ibs_mean%*%ons)/sam_siz[smpl])
low_ibs <- t(ons) %*% asg - crt_val * tmp_sd
up_ibs <- t(ons) %*% asg + crt_val * tmp_sd
cover_ibs[cn, smpl] <- as.numeric (t(ons)%*%parm<=up_ibs&t(ons)%*%parm>=low_ibs)
low_ibs
up_ibs
t(ons)%*%parm
39*50/3600

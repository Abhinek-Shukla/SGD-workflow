lines(sq_n, forb_norm_all[, 4],  lwd = 2, col = "tomato", lty = 1, type = "b")
arrows(sq_n, forb_norm_all[, 4], sq_n, forb_norm_all[, 4] + sd_forb_norm[, 4], length=0.05, angle=90, col = "tomato", lwd = 2, lty = 1 )
arrows(sq_n, forb_norm_all[, 4], sq_n, forb_norm_all[, 4] - sd_forb_norm[, 4], length=0.05, angle=90, col = "tomato", lwd = 2, lty = 1 )
lines(sq_n, forb_norm_all[, 5],  lwd = 2, col = "yellow", lty = 1, type = "b")
arrows(sq_n, forb_norm_all[, 5], sq_n, forb_norm_all[, 5] + sd_forb_norm[, 5], length=0.05, angle=90, col = "yellow", lwd = 2, lty = 1 )
arrows(sq_n, forb_norm_all[, 5], sq_n, forb_norm_all[, 5] - sd_forb_norm[, 5], length=0.05, angle=90, col = "yellow", lwd = 2, lty = 1 )
lines(sq_n, forb_norm_all[, 6],  lwd = 2, col = "brown", lty = 2, type = "b")
arrows(sq_n, forb_norm_all[, 6], sq_n, forb_norm_all[, 6] + sd_forb_norm[, 6], length=0.05, angle=90, col = "brown", lwd = 2, lty = 1 )
arrows(sq_n, forb_norm_all[, 6], sq_n, forb_norm_all[, 6] - sd_forb_norm[, 6], length=0.05, angle=90, col = "brown", lwd = 2, lty = 1 )
lines(sq_n, forb_norm_all[, 7],  lwd = 2, col = "tomato", lty = 2, type = "b")
arrows(sq_n, forb_norm_all[, 7], sq_n, forb_norm_all[, 7] + sd_forb_norm[, 7], length=0.05, angle=90, col = "tomato", lwd = 2, lty = 1 )
arrows(sq_n, forb_norm_all[, 7], sq_n, forb_norm_all[, 7] - sd_forb_norm[, 7], length=0.05, angle=90, col = "tomato", lwd = 2, lty = 1 )
lines(sq_n, forb_norm_all[, 8],  lwd = 2, col = "yellow", lty = 2, type = "b")
arrows(sq_n, forb_norm_all[, 8], sq_n, forb_norm_all[, 8] + sd_forb_norm[, 8], length=0.05, angle=90, col = "yellow", lwd = 2, lty = 1 )
arrows(sq_n, forb_norm_all[, 8], sq_n, forb_norm_all[, 8] - sd_forb_norm[, 8], length=0.05, angle=90, col = "yellow", lwd = 2, lty = 1 )
legend("bottom", legend = names_var,
col = col_choic, lwd = 2, lty = lin_typ, cex=1.2,
box.lty=1, box.lwd=2, ncol = 4)
dev.off()
install.packages("truncnorm")
install.packages("truncnorm", dependencies = T)
install.packages("Rtools")
-sqrt(15/16)
-sqrt(360/384)
(9.11)*10-4.5
(9.19)*10-4.5
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/ebs_with_dong_implement/logistic")
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e5
nparm <- 5
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 20
nam_matrix = "indep"
gradnt_log <- function(y,a,sg){
tmp <- (c( 1 + exp(  y*t(a )%*% (sg))))
p_thet <- 1/ tmp
return(-y*p_thet*a)
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
A = diag(nparm)
eta_cns = 0.5
sam_siz = c(5e4,1e5,2e5,5e5,8e5,1e6,5e6,1e7)
qlev = 0.95
alp = .505
burn_in = 1000
Rep <- 1
cn <- 1
sam_siz <- sam_siz[sam_siz <= max_sam]
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
load("out/sigm_inv_logist.RData")
sigm_inv <- get(paste("sigm_inv_",nam_matrix,"_nparm_", nparm, sep= ""))
sigm <- qr.solve(sigm_inv)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs <- forb_ebs <- forb_ebs_norm <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_ebs <- volm_ebs_ls <-  matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
p1 <- 1/(1 + exp(-x %*% parm))# Prob of success for 1 (1-p1 is for -1)
y<-2*rbinom(n + burn_in, size = 1, prob = p1) - 1
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * gradnt_log( y[i], x[i,], sg[i - 1,])
if(sum(is.na(gradnt_log( y[i], x[i,], sg[i - 1,]))) >= 1){print(c(sg[i-1],i))}
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
smpl <- 1
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val))
crt_val_ebs <- qf(qlev, df1 = nparm, df2 = (an - nparm))
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val))
crt_val_ebs <- qf(qlev, df1 = nparm, df2 = (an - nparm))
bn <- floor(n/an)
updt_crt <- ( sam_siz[smpl] * nparm / ((an - nparm) * bn))
crt_val_ebs <- crt_val_ebs * updt_crt
ebs_mean <- ebs_batch_mean_dong(sg_ct, an, bn,  alp, 1)
forb_ebs_norm[cn, smpl] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[cn, smpl]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[cn, smpl]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val_ebs)
print(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) )
crt_val_ebs
crt_val
solve(sigm)
qr.solve(ebs_mean )
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e5
nparm <- 5
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 20
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 200, ncores_par = 1, nam_matrix = nam_matrix)
foo <- paste("out/logistic_", nam_matrix,"_n_",max_sam,"_dim_",nparm,"_dong.RData",sep="")
load(foo)
colMeans(cover_orc)
colMeans(cover_ebs)
colMeans(cover_ebs_ls)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e5
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 25
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 200, ncores_par = 1, nam_matrix = nam_matrix)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e5
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 25
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 2, ncores_par = 1, nam_matrix = nam_matrix)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e5
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 25
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 2, ncores_par = 1, nam_matrix = nam_matrix)
foo <- paste("out/logistic_", nam_matrix,"_n_",max_sam,"_dim_",nparm,"_dong.RData",sep="")
load(foo)
colMeans(cover_orc)
colMeans(cover_ebs)
colMeans(cover_ebs_ls)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e5
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 25
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 20, ncores_par = 1, nam_matrix = nam_matrix)
foo <- paste("out/logistic_", nam_matrix,"_n_",max_sam,"_dim_",nparm,"_dong.RData",sep="")
load(foo)
colMeans(cover_orc)
colMeans(cover_ebs)
colMeans(cover_ebs_ls)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e5
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 25
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 200, ncores_par = 1, nam_matrix = nam_matrix)
foo <- paste("out/logistic_", nam_matrix,"_n_",max_sam,"_dim_",nparm,"_dong.RData",sep="")
load(foo)
colMeans(cover_orc)
colMeans(cover_ebs)
colMeans(cover_ebs_ls)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 25
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 2, ncores_par = 1, nam_matrix = nam_matrix)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 25
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 2, ncores_par = 1, nam_matrix = nam_matrix)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 29
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 2, ncores_par = 1, nam_matrix = nam_matrix)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 30
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 2, ncores_par = 1, nam_matrix = nam_matrix)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 30
nam_matrix = "indep"
gradnt_log <- function(y,a,sg){
tmp <- (c( 1 + exp(  y*t(a )%*% (sg))))
p_thet <- 1/ tmp
return(-y*p_thet*a)
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
A = diag(nparm)
eta_cns = 0.5
sam_siz = c(1e5,2e5,5e5,8e5,1e6,5e6,1e7)
qlev = 0.95
alp = .505
burn_in = 1000
sam_siz <- sam_siz[sam_siz <= max_sam]
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
load("out/sigm_inv_logist.RData")
sigm_inv <- get(paste("sigm_inv_",nam_matrix,"_nparm_", nparm, sep= ""))
sigm <- qr.solve(sigm_inv)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs <- forb_ebs <- forb_ebs_norm <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_ebs <- volm_ebs_ls <-  matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
Rep <- 1
cn <- 1
sam_siz <- sam_siz[sam_siz <= max_sam]
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
load("out/sigm_inv_logist.RData")
sigm_inv <- get(paste("sigm_inv_",nam_matrix,"_nparm_", nparm, sep= ""))
sigm <- qr.solve(sigm_inv)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs <- forb_ebs <- forb_ebs_norm <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_ebs <- volm_ebs_ls <-  matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
p1 <- 1/(1 + exp(-x %*% parm))# Prob of success for 1 (1-p1 is for -1)
y<-2*rbinom(n + burn_in, size = 1, prob = p1) - 1
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * gradnt_log( y[i], x[i,], sg[i - 1,])
if(sum(is.na(gradnt_log( y[i], x[i,], sg[i - 1,]))) >= 1){print(c(sg[i-1],i))}
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
for ( smpl in 1 : length(sam_siz))
{
print(sam_siz[smpl])
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val))
crt_val_ebs <- qf(qlev, df1 = nparm, df2 = (an - nparm))
bn <- floor(n/an)
updt_crt <- ( sam_siz[smpl] * nparm / ((an - nparm) * bn))
crt_val_ebs <- crt_val_ebs * updt_crt
ebs_mean <- ebs_batch_mean_dong(sg_ct, an, bn,  alp, 1)
forb_ebs_norm[cn, smpl] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[cn, smpl]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[cn, smpl]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val_ebs)
print(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) )
ebs_mean <- ebs_batch_mean_dong(sg_ct, an, bn,  alp, 2)
forb_ebs_norm_ls[cn, smpl] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[cn, smpl]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[cn, smpl]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val_ebs)
print(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) )
}
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 30
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 2, ncores_par = 1, nam_matrix = nam_matrix)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 30
nam_matrix = "indep"
gradnt_log <- function(y,a,sg){
tmp <- (c( 1 + exp(  y*t(a )%*% (sg))))
p_thet <- 1/ tmp
return(-y*p_thet*a)
}
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
A = diag(nparm)
eta_cns = 0.5
sam_siz = c(2e5,5e5,8e5,1e6,5e6,1e7)
qlev = 0.95
alp = .505
burn_in = 1000
Rep <- 1
cn <- 1
sam_siz <- sam_siz[sam_siz <= max_sam]
n <- sam_siz[length(sam_siz)]
parm <- seq(1 / nparm, 1, length.out = nparm)
load("out/sigm_inv_logist.RData")
sigm_inv <- get(paste("sigm_inv_",nam_matrix,"_nparm_", nparm, sep= ""))
sigm <- qr.solve(sigm_inv)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs <- forb_ebs <- forb_ebs_norm <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_ebs <- volm_ebs_ls <-  matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
p1 <- 1/(1 + exp(-x %*% parm))# Prob of success for 1 (1-p1 is for -1)
y<-2*rbinom(n + burn_in, size = 1, prob = p1) - 1
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * gradnt_log( y[i], x[i,], sg[i - 1,])
if(sum(is.na(gradnt_log( y[i], x[i,], sg[i - 1,]))) >= 1){print(c(sg[i-1],i))}
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
for ( smpl in 1 : length(sam_siz))
{
print(sam_siz[smpl])
sg_ct <- sg_ct_full[1 : sam_siz[smpl], ]
asg <- colMeans(sg_ct)
#Oracle coverage
cover_orc[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
print(as.numeric(sam_siz[smpl]  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val))
crt_val_ebs <- qf(qlev, df1 = nparm, df2 = (an - nparm))
bn <- floor(n/an)
updt_crt <- ( sam_siz[smpl] * nparm / ((an - nparm) * bn))
crt_val_ebs <- crt_val_ebs * updt_crt
ebs_mean <- ebs_batch_mean_dong(sg_ct, an, bn,  alp, 1)
forb_ebs_norm[cn, smpl] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[cn, smpl]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[cn, smpl]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val_ebs)
print(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) )
ebs_mean <- ebs_batch_mean_dong(sg_ct, an, bn,  alp, 2)
forb_ebs_norm_ls[cn, smpl] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[cn, smpl]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[cn, smpl]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[cn, smpl] <- as.numeric(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val_ebs)
print(sam_siz[smpl]  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) )
}
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("gradnt_log_dong_implement.R")
source("./../ebs_batch_mean_dong.R")
source("./../sqrt_mat.R")
max_sam <- 1e6
nparm <- 20
if(nparm < 10){ an = 20}
if(nparm > 10){an = nparm + 8}
an = 40
nam_matrix = "indep"
log_batch_fn(max_sam = max_sam, an = an,  nparm = nparm, Rep = 1, ncores_par = 1, nam_matrix = nam_matrix)

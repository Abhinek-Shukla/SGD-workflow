k1<-length(lt1);k2<-length(lt2)
coun2<-rep(1,k1)
for(m in 1:k1)
{for( n in 1:k2){
if(obj_fn(c(lt1[m],lt2[n]),y)>=obj_fn(c(lt1[m],lt2[coun2[m]]),y)){coun2[m]=coun2[m]}
else{coun2[m]=n}
}}
coun1=1
for(m in 1:k1){
if(obj_fn(c(lt1[m],lt2[coun2[m]]),y)>=obj_fn(c(lt1[coun1],lt2[coun2[coun1]]),y)){coun1=coun1}
else{coun1=m}
}
return(c(coun1,coun2[coun1]))
}
#########################################################################
four_trans<-function(fq1,fq2,conj_sig){dft_sig<-0
for( m in 1: nrow(conj_sig)){
for( n in 1: ncol(conj_sig)){
dft_sig<-dft_sig+conj_sig[m,n]*(cos(2*pi*(fq1*m+fq2*n))-1i*sin(2*pi*(fq1*m+fq2*n)))
}
}
-abs(dft_sig)
}
four_trans_op<-function(fq,conj_sig){dft_sig<-0
for( m in 1: nrow(conj_sig)){
for( n in 1: ncol(conj_sig)){
dft_sig<-dft_sig+conj_sig[m,n]*(cos(2*pi*(fq[1]*m+fq[2]*n))-1i*sin(2*pi*(fq[1]*m+fq[2]*n)))
}
}
-abs(dft_sig)
}
mult_lg_haf<-function(y0){ M<-nrow(y0);N<-ncol(y0);s1<-y_est<-matrix(nrow=M,ncol=N)
s1<-y0
#### Lagged Data Sequences ####
tau1<-1;tau2<-1;thet1<-0;thet2<-1;
s2<-matrix(nrow=M-tau1,ncol=N-thet1);s3<-matrix(nrow=M-tau2,ncol=N-thet2)
for(m in 1:M){
for (n in 1:N){
if(m+tau1<=M&n+thet1<=N) {s2[m,n]<- Conj(s1[m,n])*s1[(m+tau1),(n+thet1)]}
if(m+tau2<=M&n+thet2<=N) {s3[m,n]<- Conj(s1[m,n])*s1[(m+tau2),(n+thet2)]}
}
}
a_1<-seq(1,M-1)/(2*M);a_2<-seq(1,N-1)/(4*N)
b_1<-seq(1,M-1)/(M);b_2<-seq(1,N-1)/(N)
tmpr1<-grd_comp_haf(a_1,a_2,y=s2)
tmpr2<-grd_comp_haf(b_1,b_2,y=s3)
tmp1<-optim(par=c(a_1[tmpr1[1]],a_2[tmpr1[2]]),fn=four_trans_op,conj_sig=s2)$par
tmp2<-optim(par=c(b_1[tmpr2[1]],b_2[tmpr2[2]]),fn=four_trans_op,conj_sig=s3)$par
f1<-tmp1[1];v1<-tmp1[2]
f2<-tmp2[1];v2<-tmp2[2]
est_secnd_ord<-vector()
est_secnd_ord<-c(f1,v1,f2,v2)
cof_mat<-matrix(c(2*tau1,thet1,0,0,tau1,2*thet1,   2*tau2,thet2,0,0,tau2,2*thet2),nrow=4,ncol=3,byrow=T)
finl_est<-solve(t(cof_mat)%*%cof_mat)%*%t(cof_mat)%*%est_secnd_ord
b_est<-vector()
b_est[2]<-finl_est[1];b_est[5]<-finl_est[2];b_est[4]<-finl_est[3]
for(m in 1:M){
for (n in 1:N){
y_est[m,n]=s1[m,n]*(cos(2*pi*(b_est[2]*m^2+b_est[4]*n^2+b_est[5]*m*n))-sqrt(as.complex(-1))*sin(2*pi*(b_est[2]*m^2+b_est[4]*n^2+b_est[5]*m*n)))
}
}
c_1<-seq(1,M-1)/M
tmpr3<-grd_comp_haf(c_1,b_2,y=y_est)
tmp1<-optim(par=c(c_1[tmpr3[1]],a_2[tmpr3[2]]),fn=four_trans_op,conj_sig=y_est)$par
b_est[1]<-tmp1[1];b_est[3]<-tmp1[2]
return(b_est)
}
grd_comp_haf<-function(lt1,lt2,y){
k1<-length(lt1);k2<-length(lt2)
coun2<-rep(1,k1)
for(m in 1:k1)
{for( n in 1:k2){
if(four_trans(lt1[m],lt2[n],conj_sig=y)>=four_trans(lt1[m],lt2[coun2[m]],conj_sig=y)){coun2[m]=coun2[m]}
else{coun2[m]=n}
}}
coun1=1
for(m in 1:k1){
if(four_trans(lt1[m],lt2[coun2[m]],conj_sig=y)>=four_trans(lt1[coun1],lt2[coun2[coun1]],conj_sig=y)){coun1=coun1}
else{coun1=m}
}
return(c(coun1,coun2[coun1]))
}
est_dt<-function(b){
y_est_init<-matrix(nrow=M,ncol=N)
for(m in 1:M){
for(n in 1:N){
y_est_init[m,n]<- A*cos(2*pi*(b[1]*m+b[2]*m^2+b[3]*n+b[4]*n^2+b[5]*m*n))
}
}
return(y_est_init)
}
###################################################################
# Estimating using efficient
a_1<-seq(1,(M-1),by=1)/(M);a_2<-seq(1,(M^2-1),by=1)/(2*M^2)
b_1<-seq(1,(N-1),by=1)/(N);b_2<-seq(1,(N^2-1),by=1)/(2*N^2)
lst_1<-list(a_1,a_2)
temp1<-temp3<-temp5<-matrix(nrow=N,ncol=2);temp2<-temp4<-temp6<-matrix(nrow=M,ncol=2)
for (n in 1:N)
{ lst_1<-list(a_1,a_2)
tmpr<-grd_comp(a_1,a_2,y[,n])
temp1[n,]<-c(a_1[tmpr[1]],a_2[tmpr[2]])
if(n>1){if(temp1[n,1]<temp1[(n-1),1]){temp1[n,1]=temp1[n,1]+1;a_1=a_1+1}}
}
for (m in 1:M)
{
lst_2<-list(b_1,b_2)
tmpr<-grd_comp(b_1,b_2,y[m,])
temp2[m,]<-c(b_1[tmpr[1]],b_2[tmpr[2]])
if(m>1){if(temp2[m,1]<temp2[(m-1),1]){temp2[m,1]=temp2[m,1]+1;b_1=b_1+1}}
}
for (n in 1:N)
{ lst_1<-list(a_1,a_2)
temp3[n,]<-optim(par=temp1[n,],obj_fn,y=y[,n])$par
if(n>1){if(temp3[n,1]<temp3[(n-1),1]){temp3[n,1]=temp3[n,1]+1}}
}
for (m in 1:M)
{
lst_2<-list(b_1,b_2)
temp4[m,]<-optim(par=temp2[m,],obj_fn,y=y[m,])$par
if(m>1){if(temp4[m,1]<temp4[(m-1),1]){temp4[m,1]=temp4[m,1]+1}}
}
b4<-comb(temp3,temp4);
b4
a
k=1;W<-vector()
for (n in 1:N){
for(m in 1:M){
W[k]=c(cos(2*pi*(b4[1]*m+b4[2]*(m^2)+b4[3]*n+b4[4]*(n^2)+b4[5]*m*n)) +1i* sin(2*pi*(b4[1]*m+b4[2]*(m^2)+b4[3]*n+b4[4]*(n^2)+b4[5]*m*n)));k=k+1
}
}
Y<-vector()
for (n in 1:N){
Y<-c(Y,y[,n])
}
solve(t(Conj(W))%*% W)%*%t(Conj(W))%*%Y
Amp1 <- solve(t(Conj(W))%*% W)%*%t(Conj(W))%*%Y
y_est_init<-matrix(nrow=M,ncol=N)
for(m in 1:M){
for(n in 1:N){
y_est_init[m,n]<- Amp1*cos(2*pi*(b[1]*m+b[2]*m^2+b[3]*n+b[4]*n^2+b[5]*m*n)) + 1i*Amp1*sin(2*pi*(b[1]*m+b[2]*m^2+b[3]*n+b[4]*n^2+b[5]*m*n))
}
}
###################################################################
# Estimating using efficient second component
y <- y - y_est_init
y <- y - y_est_init
a_1<-seq(1,(M-1),by=1)/(M);a_2<-seq(1,(M^2-1),by=1)/(2*M^2)
b_1<-seq(1,(N-1),by=1)/(N);b_2<-seq(1,(N^2-1),by=1)/(2*N^2)
lst_1<-list(a_1,a_2)
temp1<-temp3<-temp5<-matrix(nrow=N,ncol=2);temp2<-temp4<-temp6<-matrix(nrow=M,ncol=2)
for (n in 1:N)
{ lst_1<-list(a_1,a_2)
tmpr<-grd_comp(a_1,a_2,y[,n])
temp1[n,]<-c(a_1[tmpr[1]],a_2[tmpr[2]])
if(n>1){if(temp1[n,1]<temp1[(n-1),1]){temp1[n,1]=temp1[n,1]+1;a_1=a_1+1}}
}
for (m in 1:M)
{
lst_2<-list(b_1,b_2)
tmpr<-grd_comp(b_1,b_2,y[m,])
temp2[m,]<-c(b_1[tmpr[1]],b_2[tmpr[2]])
if(m>1){if(temp2[m,1]<temp2[(m-1),1]){temp2[m,1]=temp2[m,1]+1;b_1=b_1+1}}
}
for (n in 1:N)
{ lst_1<-list(a_1,a_2)
temp3[n,]<-optim(par=temp1[n,],obj_fn,y=y[,n])$par
if(n>1){if(temp3[n,1]<temp3[(n-1),1]){temp3[n,1]=temp3[n,1]+1}}
}
for (m in 1:M)
{
lst_2<-list(b_1,b_2)
temp4[m,]<-optim(par=temp2[m,],obj_fn,y=y[m,])$par
if(m>1){if(temp4[m,1]<temp4[(m-1),1]){temp4[m,1]=temp4[m,1]+1}}
}
b4_2<-comb(temp3,temp4);
lst_1
for (n in 1:N)
{ lst_1<-list(a_1,a_2)
tmpr<-grd_comp(a_1,a_2,y[,n])
temp1[n,]<-c(a_1[tmpr[1]],a_2[tmpr[2]])
if(n>1){if(temp1[n,1]<temp1[(n-1),1]){temp1[n,1]=temp1[n,1]+1;a_1=a_1+1}}
}
y
y_est_init
#plot(as.cimg(y-x),axes=F)
#plot(as.cimg(y),axes=F)
y<-y_real_noisy+y1
Amp1
y_est_init<-matrix(nrow=M,ncol=N)
for(m in 1:M){
for(n in 1:N){
y_est_init[m,n]<- Amp1*cos(2*pi*(b4[1]*m+b4[2]*m^2+b4[3]*n+b4[4]*n^2+b4[5]*m*n)) + 1i*Amp1*sin(2*pi*(b4[1]*m+b4[2]*m^2+b4[3]*n+b4[4]*n^2+b4[5]*m*n))
}
}
y_est_init
###################################################################
# Estimating using efficient second component
y <- y - y_est_init
a_1<-seq(1,(M-1),by=1)/(M);a_2<-seq(1,(M^2-1),by=1)/(2*M^2)
b_1<-seq(1,(N-1),by=1)/(N);b_2<-seq(1,(N^2-1),by=1)/(2*N^2)
lst_1<-list(a_1,a_2)
temp1<-temp3<-temp5<-matrix(nrow=N,ncol=2);temp2<-temp4<-temp6<-matrix(nrow=M,ncol=2)
for (n in 1:N)
{ lst_1<-list(a_1,a_2)
tmpr<-grd_comp(a_1,a_2,y[,n])
temp1[n,]<-c(a_1[tmpr[1]],a_2[tmpr[2]])
if(n>1){if(temp1[n,1]<temp1[(n-1),1]){temp1[n,1]=temp1[n,1]+1;a_1=a_1+1}}
}
for (m in 1:M)
{
lst_2<-list(b_1,b_2)
tmpr<-grd_comp(b_1,b_2,y[m,])
temp2[m,]<-c(b_1[tmpr[1]],b_2[tmpr[2]])
if(m>1){if(temp2[m,1]<temp2[(m-1),1]){temp2[m,1]=temp2[m,1]+1;b_1=b_1+1}}
}
for (n in 1:N)
{ lst_1<-list(a_1,a_2)
temp3[n,]<-optim(par=temp1[n,],obj_fn,y=y[,n])$par
if(n>1){if(temp3[n,1]<temp3[(n-1),1]){temp3[n,1]=temp3[n,1]+1}}
}
for (m in 1:M)
{
lst_2<-list(b_1,b_2)
temp4[m,]<-optim(par=temp2[m,],obj_fn,y=y[m,])$par
if(m>1){if(temp4[m,1]<temp4[(m-1),1]){temp4[m,1]=temp4[m,1]+1}}
}
b4_2<-comb(temp3,temp4);
b4_2
a
a1
Iter = 20
snr <- 5
ncomp <- 2
rho <- -0.5
alph <- mvrnorm(ncomp, mu = rep(0,2), Sigma = matrix(c(1, rho, rho, 1), nrow = 2))
library(MASS)
alph <- mvrnorm(ncomp, mu = rep(0,2), Sigma = matrix(c(1, rho, rho, 1), nrow = 2))
alph
alph <- matrix(alph, nrow = ncomp)
for(k in 1 : ncomp)
{
alph[k, ] <- c(2*pi * (pnorm(alph[k, 1])), (pi/2) * (pnorm(alph[k, 2])))
}
alph
K <- 5
for(i in 1 : 2*K){
for(j in 1 : 2*K){
print(round(i/2))
#hess[i,j] =
}
}
hess_matr <-  function(K, Y,alph)
{N <- length(Y)
hess <- matrix(nrow = 2*K, ncol = 2*K)
for(i in 1 : 2*K){
for(j in 1 : 2*K){
print(round(i/2))
#hess[i,j] =
}
}
}
for(i in 1 : 2*K){
print(round(i/2))
for(j in 1 : 2*K){
#hess[i,j] =
}
}
for(i in 1 : 2*K){
print(i)
print(round(i/2))
for(j in 1 : 2*K){
#hess[i,j] =
}
}
for(i in 1 : (2*K)){
print(i)
print(round(i/2))
for(j in 1 : 2*K){
#hess[i,j] =
}
}
(i %% 2)
i
for(i in 1 : (2*K)){
print(i)
print(round(i/2) + (i %% 2))
for(j in 1 : 2*K){
#hess[i,j] =
}
}
for( i in 1 : K){indx[c(cont, cont + 1)] <- rep(i, 2)
cont = cont + 1
}
indx <- vector()
for( i in 1 : K){indx[c(cont, cont + 1)] <- rep(i, 2)
cont = cont + 1
}
indx <- vector(); cont = 1
for( i in 1 : K){indx[c(cont, cont + 1)] <- rep(i, 2)
cont = cont + 1
}
indx
K
indx <- vector(); cont = 1
for( i in 1 : K){indx[cont : cont + 1] <- rep(i, 2)
cont = cont + 1
}
rep(i, 2)
indx[cont : cont + 1]
indx <- vector(); cont = 1
for( i in 1 : K){indx[cont : (cont + 1)] <- rep(i, 2)
cont = cont + 1
}
indx
indx <- vector(); cont = 1
for( i in 1 : K){indx[cont : (cont + 1)] <- rep(i, 2)
cont = cont + 2
}
indx
indx[3]
indx[5]
indx[6]
indx[7]
indx[8]
for(i in 1 : (2*K)){
for(j in 1 : 2*K){
print(c(indx[i], indx[j])
#hess[i,j] =
}
}
}
K <- 5
for(i in 1 : (2*K)){
for(j in 1 : 2*K){
print(c(indx[i], indx[j]))
#hess[i,j] =
}
}
for(i in 1 : (2*K)){
for(j in 1 : (2*K)){
print(c(indx[i], indx[j]))
#hess[i,j] =
}
}
Sys.which("make")
Sys.which("make")
setwd("~/")
Sys.which("make")
write('PATH="${RTOOLS40_HOME}\\usr\\bin;${PATH}"', file = "~/.Renviron", append = TRUE)
Sys.which("make")
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
library(mvtnorm)
source("logistic_main.R")
source("./../ebs.R")
source("./../ibs.R")
source("./../misc.R")
### Load Data ###
dta_org <- read.csv(file="train_cust_trans.csv", header=FALSE, sep=",", stringsAsFactors=FALSE)
names(dta_org) <- NULL
dta <- as.matrix(dta_org[-1, 2 : 52])
rownames(dta) <- NULL
dta <- matrix(as.numeric(dta), nrow = nrow(dta), ncol = ncol(dta))
dta[, 1] <- 2 * dta[, 1] - 1
# Had to transform into -1,1 type of binary setup, for the gradient considered from Chen AOS (2020).
log_batch_fn(max_sam = 2e5, eta_cns = 0.05, alp = .51, cns = c(0.1), cns1 = 0.01, burn_in = 5000, sam_siz = c(1e5,2e5), dta = dta)
load("out/logistic_real_dim_50.RData")
### Joint region Volume Comparison ###
c( volm_ibs[2], volm_ebs[2, 2], volm_ebs_ls[2, 2])
### Marginal friendly inferences ###
### Max Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_max <-  max(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_max <-  max(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_max <-  max(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_max, ibs_ebs_ls_comprs_max, ebs_ls_ebs_comprs_max)
### min Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_min <-  min(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_min <-  min(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_min <-  min(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_min, ibs_ebs_ls_comprs_min, ebs_ls_ebs_comprs_min)
### Mean Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_mean <-  mean(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_mean <-  mean(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_mean <-  mean(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_mean, ibs_ebs_ls_comprs_mean, ebs_ls_ebs_comprs_mean)
### Marginal friendly region volume of cuboids  inflated with respect to joint ###
c(marg_volm_ibs[2], marg_volm_ebs[2, 2], marg_volm_ebs_ls[2, 2])
setwd("~/GitHub/Batch_Means_Online/real_data_analysis")
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
library(mvtnorm)
source("logistic_main.R")
source("./../ebs.R")
source("./../ibs.R")
source("./../misc.R")
### Load Data ###
dta_org <- read.csv(file="train_cust_trans.csv", header=FALSE, sep=",", stringsAsFactors=FALSE)
names(dta_org) <- NULL
dta <- as.matrix(dta_org[-1, 2 : 52])
rownames(dta) <- NULL
dta <- matrix(as.numeric(dta), nrow = nrow(dta), ncol = ncol(dta))
dta[, 1] <- 2 * dta[, 1] - 1
# Had to transform into -1,1 type of binary setup, for the gradient considered from Chen AOS (2020).
log_batch_fn(max_sam = 2e5, eta_cns = 0.05, alp = .51, cns = c(0.1), cns1 = 0.01, burn_in = 5000, sam_siz = c(1e5,2e5), dta = dta)
load("out/logistic_real_dim_50.RData")
### Joint region Volume Comparison ###
c( volm_ibs[2], volm_ebs[2, 2], volm_ebs_ls[2, 2])
### Marginal friendly inferences ###
### Max Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_max <-  max(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_max <-  max(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_max <-  max(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_max, ibs_ebs_ls_comprs_max, ebs_ls_ebs_comprs_max)
### min Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_min <-  min(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_min <-  min(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_min <-  min(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_min, ibs_ebs_ls_comprs_min, ebs_ls_ebs_comprs_min)
### Mean Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_mean <-  mean(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_mean <-  mean(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_mean <-  mean(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_mean, ibs_ebs_ls_comprs_mean, ebs_ls_ebs_comprs_mean)
### Marginal friendly region volume of cuboids  inflated with respect to joint ###
c(marg_volm_ibs[2], marg_volm_ebs[2, 2], marg_volm_ebs_ls[2, 2])
tmp1 <- margn_up_low[[1]]
tmp1
sort(tmp1[, 2] - tmp1[, 1])
which(len_1 == sort(len_1))
len_1 <- (tmp1[, 2] - tmp1[, 1])
which(len_1 == sort(len_1))
order( sort(len_1))
order(len_1)
tmp1[order(len_1), ]
order(len_1)
len_1
max(len_1)
tmp1[order(len_1), ]
tmp1[order(len_1), c(1 : 5, 46 : 50)]
indx <- c(1 : 5, 46 : 50)
tmp1[order(len_1), indx]
len_1
order(len_1)
tmp1[order(len_1), ]
tmp2[indx, ]
indx <- c(1 : 5, 46 : 50)
tmp2 <- tmp1[order(len_1), ]
tmp2[indx, ]
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
library(mvtnorm)
source("logistic_main.R")
source("./../ebs.R")
source("./../ibs.R")
source("./../misc.R")
### Load Data ###
dta_org <- read.csv(file="train_cust_trans.csv", header=FALSE, sep=",", stringsAsFactors=FALSE)
names(dta_org) <- NULL
dta <- as.matrix(dta_org[-1, 2 : 52])
rownames(dta) <- NULL
dta <- matrix(as.numeric(dta), nrow = nrow(dta), ncol = ncol(dta))
dta[, 1] <- 2 * dta[, 1] - 1
# Had to transform into -1,1 type of binary setup, for the gradient considered from Chen AOS (2020).
log_batch_fn(max_sam = 2e5, eta_cns = 0.05, alp = .51, cns = c(0.1), cns1 = 0.01, burn_in = 5000, sam_siz = c(1e5,2e5), dta = dta)
load("out/logistic_real_dim_50.RData")
### Joint region Volume Comparison ###
c( volm_ibs[2], volm_ebs[2, 2], volm_ebs_ls[2, 2])
### Marginal friendly inferences ###
### Max Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_max <-  max(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_max <-  max(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_max <-  max(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_max, ibs_ebs_ls_comprs_max, ebs_ls_ebs_comprs_max)
### min Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_min <-  min(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_min <-  min(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_min <-  min(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_min, ibs_ebs_ls_comprs_min, ebs_ls_ebs_comprs_min)
### Mean Ratio of lengths of intervals among different dimensions ###
ibs_ebs_comprs_mean <-  mean(ratio_ibs_ebs[2, 2, ])
ibs_ebs_ls_comprs_mean <-  mean(ratio_ibs_ebs_ls[2, 2, ])
ebs_ls_ebs_comprs_mean <-  mean(ratio_ebs_ls_ebs[2, 2, ])
c(ibs_ebs_comprs_mean, ibs_ebs_ls_comprs_mean, ebs_ls_ebs_comprs_mean)
### Marginal friendly region volume of cuboids  inflated with respect to joint ###
c(marg_volm_ibs[2], marg_volm_ebs[2, 2], marg_volm_ebs_ls[2, 2])
tmp1 <- margn_up_low[[1]]
len_1 <- (tmp1[, 2] - tmp1[, 1])
indx <- c(1 : 5, 46 : 50)
tmp2 <- tmp1[order(len_1), ]
tmp2[indx, ]#IBS
tmp1 <- margn_up_low[[4]]
len_1 <- (tmp1[, 2] - tmp1[, 1])
indx <- c(1 : 5, 46 : 50)
tmp2 <- tmp1[order(len_1), ]
tmp2[indx, ]#EBS
tmp1 <- margn_up_low[[5]]
len_1 <- (tmp1[, 2] - tmp1[, 1])
indx <- c(1 : 5, 46 : 50)
tmp2 <- tmp1[order(len_1), ]
tmp2[indx, ] #EBS + Lugsail

arrows(sq_n, forb_norm_all[, 13], sq_n, forb_norm_all[, 13] - sd_forb_norm[, 13], length=0.05, angle=90, col = "magenta3", lwd = 2, lty = 1 )
lines(sq_n, forb_norm_all[, 14],  lwd = 2, col = "palegreen", lty = 2, type = "b")
arrows(sq_n, forb_norm_all[, 14], sq_n, forb_norm_all[, 14] + sd_forb_norm[, 14], length=0.05, angle=90, col = "palegreen", lwd = 2, lty = 1 )
arrows(sq_n, forb_norm_all[, 14], sq_n, forb_norm_all[, 14] - sd_forb_norm[, 14], length=0.05, angle=90, col = "palegreen", lwd = 2, lty = 1 )
legend("bottom", legend = names_var,
col = col_choic, lwd = 2, lty = lin_typ, cex=1.2,
box.lty=1, box.lwd=2, ncol = 5)
dev.off()
alp = 0.51
1e3^(2/(1-alp))
rm(list=ls())
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/check_value_constant")
source("ibs_lng.R")
source("ebs_lng.R")
alp <- .51
cns_sq <- c(0.1)
sq_n <- c(5e4, 1e5, 2e5, 5e5, 8e5, 1e6, 5e6, 1e7 )
leng_ebs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
leng_ibs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
for( k in 1:length(sq_n)){
n <- sq_n[k]
for (m in 1 : length(cns_sq)){
leng_ebs[m,k] <- ebs_lng(n,cns=cns_sq[m],alp,bet_typ=1)
leng_ibs[m,k] <- ibs_lng(n,cns=cns_sq[m],alp)
}
}
leng_ebs
leng_ibs
rm(list=ls())
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/check_value_constant")
source("ibs_lng.R")
source("ebs_lng.R")
alp <- .51
cns_sq <- c(0.1)
sq_n <- c(5e4, 1e5, 2e5, 5e5, 8e5, 1e6, 5e6, 1e7 )
leng_ebs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
leng_ibs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
for( k in 1:length(sq_n)){
n <- sq_n[k]
for (m in 1 : length(cns_sq)){
leng_ebs[m,k] <- ebs_lng(n,cns=cns_sq[m],alp,bet_typ=1)
leng_ibs[m,k] <- ibs_lng(n,cns=cns_sq[m],alp)
}
}
print(leng_ebs)
print(leng_ibs)
for( k in 1:length(sq_n)){
n <- sq_n[k]
for (m in 1 : length(cns_sq)){
leng_ebs[m,k] <- ebs_lng(n,cns=cns_sq[m],alp,bet_typ=2)
leng_ibs[m,k] <- ibs_lng(n,cns=cns_sq[m],alp)
}
}
leng_ebs
for( k in 1:length(sq_n)){
n <- sq_n[k]
for (m in 1 : length(cns_sq)){
leng_ebs[m,k] <- ebs_lng(n,cns=cns_sq[m],alp,bet_typ=3)
leng_ibs[m,k] <- ibs_lng(n,cns=cns_sq[m],alp)
}
}
leng_ebs
rm(list=ls())
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/check_value_constant")
source("ibs_lng.R")
source("ebs_lng.R")
alp <- .51
cns_sq <- c(0.01)
sq_n <- c(5e4, 1e5, 2e5, 5e5, 8e5, 1e6, 5e6, 1e7 )
leng_ebs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
leng_ibs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
for( k in 1:length(sq_n)){
n <- sq_n[k]
for (m in 1 : length(cns_sq)){
leng_ebs[m,k] <- ebs_lng(n,cns=cns_sq[m],alp,bet_typ=3)
leng_ibs[m,k] <- ibs_lng(n,cns=cns_sq[m],alp)
}
}
print(leng_ebs)
print(leng_ibs)
rm(list=ls())
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/check_value_constant")
source("ibs_lng.R")
source("ebs_lng.R")
alp <- .51
cns_sq <- c(0.001)
sq_n <- c(5e4, 1e5, 2e5, 5e5, 8e5, 1e6, 5e6, 1e7 )
leng_ebs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
leng_ibs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
for( k in 1:length(sq_n)){
n <- sq_n[k]
for (m in 1 : length(cns_sq)){
leng_ebs[m,k] <- ebs_lng(n,cns=cns_sq[m],alp,bet_typ=3)
leng_ibs[m,k] <- ibs_lng(n,cns=cns_sq[m],alp)
}
}
print(leng_ebs)
print(leng_ibs)
rm(list=ls())
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/check_value_constant")
source("ibs_lng.R")
source("ebs_lng.R")
alp <- .51
cns_sq <- c(0.0005)
sq_n <- c(5e4, 1e5, 2e5, 5e5, 8e5, 1e6, 5e6, 1e7 )
leng_ebs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
leng_ibs <- matrix(nrow = length(cns_sq), ncol = length(sq_n))
for( k in 1:length(sq_n)){
n <- sq_n[k]
for (m in 1 : length(cns_sq)){
leng_ebs[m,k] <- ebs_lng(n,cns=cns_sq[m],alp,bet_typ=3)
leng_ibs[m,k] <- ibs_lng(n,cns=cns_sq[m],alp)
}
}
print(leng_ebs)
print(leng_ibs)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("grad_lin_and_batch.R")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
grad_lin <- function(sg,y,x){
(x %*% (sg) - y) %*% x
}
##########################################################################################################
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 20
nparm = 50
A = diag(nparm)
cns = c(0.05) # 0.05 for fifty dimension value
ncores_par = 1
eta_cns = 1
sam_siz = 5e5
qlev = 0.95
alp = .51
burn_in = 10000
sigm <- qr.solve(A)
n <- sam_siz
parm <- seq(1 / nparm, 1, length.out = nparm)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
#Data Generated of Maximum Sample Size
for( cn in 1 : Rep ){
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
#noisy Observed Data
y <- x %*% parm + rnorm((n + burn_in), mean = 0, sd = 1)
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * grad_lin(sg[i - 1,], y[i], x[i,])
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
sg_ct <- sg_ct_full[1:sam_siz, ]
asg <- colMeans(sg_ct)
#plot.ts(sg_ct[,1:2])
#IBS and Oracle related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.0005 )
#print((ibs_mean))
forb_ibs[cn,1]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn,1] <- norm(ibs_mean, "F")
volm_ibs[cn,1]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
cover_orc[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 3){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
count = count + 1
}
}
}
#list(forb_ibs[cn,],forb_ibs_norm[cn,], volm_ibs[cn,], cover_ibs[cn,], cover_orc[cn,],  forb_ebs_norm[, cn, ], forb_ebs[, cn, ], volm_ebs[, cn, ],  cover_ebs[, cn, ], forb_ebs_norm_ls[, cn, ], forb_ebs_ls[, cn, ], volm_ebs_ls[, cn, ],  cover_ebs_ls[, cn, ]  )
print(cover_orc)
print(cover_ibs)
print(cover_ebs)
print(cover_ebs_ls)
print(cover_orc)
#fil_nam <- paste("out/linear_", nam_matrix, "_n_",max_sam,"_dim_",nparm,".RData",sep="")
#save(forb_ibs_norm,forb_ebs_norm, forb_ebs_norm_ls,cover_orc,cover_ibs,cover_ebs,cover_ebs_ls,volm_ibs,volm_ebs,volm_ebs_ls,forb_ibs,forb_ebs,forb_ebs_ls,file=fil_nam)
setwd("C:/Users/Hp/Documents/GitHub/Batch_Means_Online/linear")
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("grad_lin_and_batch.R")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
grad_lin <- function(sg,y,x){
(x %*% (sg) - y) %*% x
}
##########################################################################################################
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 20
nparm = 50
A = diag(nparm)
cns = c(0.05) # 0.05 for fifty dimension value
ncores_par = 1
eta_cns = 1
sam_siz = 5e5
qlev = 0.95
alp = .51
burn_in = 10000
sigm <- qr.solve(A)
n <- sam_siz
parm <- seq(1 / nparm, 1, length.out = nparm)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
#Data Generated of Maximum Sample Size
for( cn in 1 : Rep ){
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
#noisy Observed Data
y <- x %*% parm + rnorm((n + burn_in), mean = 0, sd = 1)
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * grad_lin(sg[i - 1,], y[i], x[i,])
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
sg_ct <- sg_ct_full[1:sam_siz, ]
asg <- colMeans(sg_ct)
#plot.ts(sg_ct[,1:2])
#IBS and Oracle related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.0005 )
#print((ibs_mean))
forb_ibs[cn,1]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn,1] <- norm(ibs_mean, "F")
volm_ibs[cn,1]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
cover_orc[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 3){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
count = count + 1
}
}
}
#list(forb_ibs[cn,],forb_ibs_norm[cn,], volm_ibs[cn,], cover_ibs[cn,], cover_orc[cn,],  forb_ebs_norm[, cn, ], forb_ebs[, cn, ], volm_ebs[, cn, ],  cover_ebs[, cn, ], forb_ebs_norm_ls[, cn, ], forb_ebs_ls[, cn, ], volm_ebs_ls[, cn, ],  cover_ebs_ls[, cn, ]  )
print(cover_orc)
print(cover_ibs)
print(cover_ebs)
print(cover_ebs_ls)
print(cover_orc)
#fil_nam <- paste("out/linear_", nam_matrix, "_n_",max_sam,"_dim_",nparm,".RData",sep="")
#save(forb_ibs_norm,forb_ebs_norm, forb_ebs_norm_ls,cover_orc,cover_ibs,cover_ebs,cover_ebs_ls,volm_ibs,volm_ebs,volm_ebs_ls,forb_ibs,forb_ebs,forb_ebs_ls,file=fil_nam)
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("grad_lin_and_batch.R")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
grad_lin <- function(sg,y,x){
(x %*% (sg) - y) %*% x
}
##########################################################################################################
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 20
nparm = 20
A = diag(nparm)
cns = c(0.05) # 0.05 for fifty dimension value
ncores_par = 1
eta_cns = 1
sam_siz = 5e5
qlev = 0.95
alp = .51
burn_in = 10000
sigm <- qr.solve(A)
n <- sam_siz
parm <- seq(1 / nparm, 1, length.out = nparm)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
#Data Generated of Maximum Sample Size
for( cn in 1 : Rep ){
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
#noisy Observed Data
y <- x %*% parm + rnorm((n + burn_in), mean = 0, sd = 1)
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * grad_lin(sg[i - 1,], y[i], x[i,])
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
sg_ct <- sg_ct_full[1:sam_siz, ]
asg <- colMeans(sg_ct)
#plot.ts(sg_ct[,1:2])
#IBS and Oracle related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.0005 )
#print((ibs_mean))
forb_ibs[cn,1]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn,1] <- norm(ibs_mean, "F")
volm_ibs[cn,1]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
cover_orc[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 3){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
count = count + 1
}
}
}
#list(forb_ibs[cn,],forb_ibs_norm[cn,], volm_ibs[cn,], cover_ibs[cn,], cover_orc[cn,],  forb_ebs_norm[, cn, ], forb_ebs[, cn, ], volm_ebs[, cn, ],  cover_ebs[, cn, ], forb_ebs_norm_ls[, cn, ], forb_ebs_ls[, cn, ], volm_ebs_ls[, cn, ],  cover_ebs_ls[, cn, ]  )
print(cover_orc)
print(cover_ibs)
print(cover_ebs)
print(cover_ebs_ls)
print(cover_orc)
#fil_nam <- paste("out/linear_", nam_matrix, "_n_",max_sam,"_dim_",nparm,".RData",sep="")
#save(forb_ibs_norm,forb_ebs_norm, forb_ebs_norm_ls,cover_orc,cover_ibs,cover_ebs,cover_ebs_ls,volm_ibs,volm_ebs,volm_ebs_ls,forb_ibs,forb_ebs,forb_ebs_ls,file=fil_nam)
gc()
rm(list=ls())
set.seed(1)
library(MASS)
library(doParallel)
library(foreach)
library(mcmcse)
source("grad_lin_and_batch.R")
source("./../ebs_batch_mean.R")
source("./../ibs_jasa_mean.R")
source("./../sqrt_mat.R")
grad_lin <- function(sg,y,x){
(x %*% (sg) - y) %*% x
}
##########################################################################################################
comb <- function(x, ...) {
lapply(seq_along(x),
function(i) c(x[[i]], lapply(list(...), function(y) y[[i]])))
}
Rep = 20
nparm = 20
A = diag(nparm)
cns = c(0.05) # 0.05 for fifty dimension value
ncores_par = 1
eta_cns = 1
sam_siz = 5e5
qlev = 0.95
alp = .51
burn_in = 10000
sigm <- qr.solve(A)
n <- sam_siz
parm <- seq(1 / nparm, 1, length.out = nparm)
crt_val <- qchisq(qlev, df = nparm)
sg <- matrix(nrow = n + burn_in, ncol = nparm);
sg_ct <- matrix(nrow = n , ncol = nparm)
#Iterates stored
# Sigma Matrix Stored with Square root
sqrt_sig <- sqrt_mat(A)
cns_ln <- 3*length(cns)# 3 multiplied due to three types of beta under study
forb_ibs <- volm_ibs <- cover_ibs <- forb_ibs_norm <- matrix(rep(0,length(sam_siz)*Rep), nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
cover_orc<- matrix(rep(0,length(sam_siz)*Rep),nrow = Rep, ncol = length(sam_siz), dimnames = list( 1 : Rep, sam_siz))
volm_ebs         <- forb_ebs <- forb_ebs_norm <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim = c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
cover_ebs        <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
volm_ebs_ls      <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
forb_ebs_norm_ls <- cover_ebs_ls  <- forb_ebs_ls <- array(rep(0, cns_ln * Rep * length(sam_siz)), dim=c(length(sam_siz), Rep, cns_ln), dimnames = list(sam_siz, 1:Rep, 1:cns_ln))
#Data Generated of Maximum Sample Size
for( cn in 1 : Rep ){
x <- matrix(rnorm((n + burn_in) * nparm), nrow = (n + burn_in), ncol = nparm)
x <- x %*% sqrt_sig
#noisy Observed Data
y <- x %*% parm + rnorm((n + burn_in), mean = 0, sd = 1)
#Learning Rate
eta <- numeric(n + burn_in)
sg[1,] <- rep(0, nparm)
for(i in 2 : (n + burn_in)){
eta[i] <- i^( - alp)
sg[i,] <- sg[i - 1,] - eta_cns * eta[i] * grad_lin(sg[i - 1,], y[i], x[i,])
}
sg_ct_full <- sg[(burn_in + 1) : (n + burn_in),]
sg_ct <- sg_ct_full[1:sam_siz, ]
asg <- colMeans(sg_ct)
#plot.ts(sg_ct[,1:2])
#IBS and Oracle related coverages and volume
ibs_mean     <- ibs_jasa_mean(sg_ct, alp, cns = 0.0005 )
#print((ibs_mean))
forb_ibs[cn,1]  <-  norm(ibs_mean - sigm, "F")/ norm(sigm, "F")  #sqrt(sum((ibs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
forb_ibs_norm[cn,1] <- norm(ibs_mean, "F")
volm_ibs[cn,1]  <- (det(ibs_mean)) ^ (1 / nparm)
cover_ibs[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% qr.solve(ibs_mean) %*% (asg - parm) <= crt_val)
cover_orc[cn,1] <- as.numeric(sam_siz  * t(asg - parm) %*% solve(sigm) %*% (asg - parm) <= crt_val)
count = 1
#Different settings of EBS, for values of cns and three types of beta
for( mk in 1 : length(cns)){ #Different values of constant cns
for(bt_typ in 1 : 3){
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 1)
forb_ebs_norm[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
ebs_mean <- ebs_batch_mean(sg_ct, alp, cns[mk], bt_typ, 2)
forb_ebs_norm_ls[1, cn, count] <- sqrt(sum((ebs_mean) ^ 2))
forb_ebs_ls[1, cn, count]  <- sqrt(sum((ebs_mean - sigm) ^ 2))/sqrt(sum(sigm ^ 2))
volm_ebs_ls[1, cn, count]  <- (det(ebs_mean) ) ^ (1 / nparm)
cover_ebs_ls[1, cn, count] <- as.numeric(sam_siz  * t(asg - parm ) %*% qr.solve(ebs_mean ) %*% (asg - parm) <= crt_val)
count = count + 1
}
}
}
#list(forb_ibs[cn,],forb_ibs_norm[cn,], volm_ibs[cn,], cover_ibs[cn,], cover_orc[cn,],  forb_ebs_norm[, cn, ], forb_ebs[, cn, ], volm_ebs[, cn, ],  cover_ebs[, cn, ], forb_ebs_norm_ls[, cn, ], forb_ebs_ls[, cn, ], volm_ebs_ls[, cn, ],  cover_ebs_ls[, cn, ]  )
print(cover_orc)
print(cover_ibs)
print(cover_ebs)
print(cover_ebs_ls)
print(cover_orc)
#fil_nam <- paste("out/linear_", nam_matrix, "_n_",max_sam,"_dim_",nparm,".RData",sep="")
#save(forb_ibs_norm,forb_ebs_norm, forb_ebs_norm_ls,cover_orc,cover_ibs,cover_ebs,cover_ebs_ls,volm_ibs,volm_ebs,volm_ebs_ls,forb_ibs,forb_ebs,forb_ebs_ls,file=fil_nam)
mean(cover_orc)
mean(cover_ibs)
mean(cover_ebs_ls[,1])
mean(cover_ebs_ls[1,])
cover_ebs_ls
mean(cover_ebs_ls[,,1])
mean(cover_ebs_ls[,,2])
mean(cover_ebs_ls[,,3])
volm_ibs
volm_ebs
volm_ebs_ls
forb_ebs
forb_ebs_ls
forb_ibs
